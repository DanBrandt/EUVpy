

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EUVpy.tools.toolbox &mdash; EUVpy 1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=29a6c3e3"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            EUVpy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../EUVpy.html">EUVpy package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../EUVpy.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../EUVpy.NEUVAC.html">EUVpy.NEUVAC package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../EUVpy.NEUVAC.html#submodules">Submodules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../EUVpy.data.html">EUVpy.data package</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../EUVpy.empiricalModels.html">EUVpy.empiricalModels package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../EUVpy.empiricalModels.html#subpackages">Subpackages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../EUVpy.tools.html">EUVpy.tools package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../EUVpy.tools.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../EUVpy.tools.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">EUVpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">EUVpy.tools.toolbox</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for EUVpy.tools.toolbox</h1><div class="highlight"><pre>
<span></span><span class="c1"># This module contains various helper functions that can be leveraged as generic tools.</span>

<span class="c1">#-----------------------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Top-level Imports</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">pickle</span><span class="o">,</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ma</span>
<span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">SimpleImputer</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">CubicSpline</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">InterpolatedUnivariateSpline</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;Qt5Agg&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pearsonr</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span> <span class="k">as</span> <span class="nn">integ</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">urlretrieve</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log10</span><span class="p">,</span> <span class="n">floor</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="c1">#-----------------------------------------------------------------------------------------------------------------------</span>

<span class="c1">#-----------------------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Local imports</span>
<span class="kn">from</span> <span class="nn">EUVpy.empiricalModels.models.SOLOMON</span> <span class="kn">import</span> <span class="n">solomon</span>
<span class="c1">#-----------------------------------------------------------------------------------------------------------------------</span>

<span class="c1">#-----------------------------------------------------------------------------------------------------------------------</span>

<span class="c1">#-----------------------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Functions</span>
<div class="viewcode-block" id="openDir">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.openDir">[docs]</a>
<span class="k">def</span> <span class="nf">openDir</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a directory, unless it already exists. Returns nothing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    directory : str</span>
<span class="sd">        A string that is the directory to be created, with respect to the current location.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Directory already exists: &#39;</span><span class="o">+</span><span class="n">directory</span><span class="p">)</span></div>


<div class="viewcode-block" id="urlObtain">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.urlObtain">[docs]</a>
<span class="k">def</span> <span class="nf">urlObtain</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Download a file from a URL. If the file already exists, don&#39;t download it; just print the location of the existing</span>
<span class="sd">    file. Returns nothing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    url : str</span>
<span class="sd">        The URL where the file is to be downloaded from.</span>
<span class="sd">    fname : str</span>
<span class="sd">        The filename which the downloaded file will be saved to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;File already exists (loading in data): &#39;</span><span class="o">+</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">urlretrieve</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span></div>


<div class="viewcode-block" id="savePickle">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.savePickle">[docs]</a>
<span class="k">def</span> <span class="nf">savePickle</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pickleFilename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some data (a list, dict, or array), save it is a pickle file with a user-supplied name. Returns nothing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : any</span>
<span class="sd">        A variable referring to data to be saved as a pickle.</span>
<span class="sd">    pickleFilename : str</span>
<span class="sd">        A string with which to name the pickle file to be saved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pickleFilename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pickleFile</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pickleFile</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span></div>


<div class="viewcode-block" id="loadPickle">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.loadPickle">[docs]</a>
<span class="k">def</span> <span class="nf">loadPickle</span><span class="p">(</span><span class="n">pickleFilename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given the name of a (pre-existing) pickle file, load its contents.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pickleFilename : str</span>
<span class="sd">        A string with the location/name of the filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    var : any</span>
<span class="sd">        The loaded data. The data type will correspond to whatever data was saved previously using savePickle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pickleFilename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pickleFile</span><span class="p">:</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pickleFile</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">var</span></div>


<div class="viewcode-block" id="firstNonNan">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.firstNonNan">[docs]</a>
<span class="k">def</span> <span class="nf">firstNonNan</span><span class="p">(</span><span class="n">listfloats</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the index of the first non-NaN value in a given sequence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    listfloats : arraylike</span>
<span class="sd">        A sequence of floats to search over.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    item : float</span>
<span class="sd">        The element that is the first non-NaN value.</span>
<span class="sd">    idx : int</span>
<span class="sd">        The index corresponding to the first non-NaN value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">listfloats</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">listfloats</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">listfloats</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">listfloats</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">item</span><span class="p">,</span> <span class="n">idx</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="find_nearest">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.find_nearest">[docs]</a>
<span class="k">def</span> <span class="nf">find_nearest</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an array, find the index and value of an item closest to a supplied value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : numpy.ndarray</span>
<span class="sd">        An array of values over which to search.</span>
<span class="sd">    value : float, int, str, datetime</span>
<span class="sd">        A value for which the closest value will be searched for.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    idx : int</span>
<span class="sd">        The index of the nearest value.</span>
<span class="sd">    array[idx] : float, int, str, datetime</span>
<span class="sd">        The actual value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">idx</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>


<div class="viewcode-block" id="uniformSample">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.uniformSample">[docs]</a>
<span class="k">def</span> <span class="nf">uniformSample</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">cadence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some data with associated time stamps, resample the data so that the data have the time resolution equal to</span>
<span class="sd">    the given cadence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xdata : arraylike</span>
<span class="sd">        A list of time stamps.</span>
<span class="sd">    ydata : arraylike</span>
<span class="sd">        A list of data/values associated with the time stamps.</span>
<span class="sd">    cadence : int</span>
<span class="sd">        An integer denoting (in hours) the desired time cadence of the data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    uniformXdata : numpy.ndarray</span>
<span class="sd">        A uniformly-sampled array of datetimes.</span>
<span class="sd">    uniformYdata : numpy.ndarray</span>
<span class="sd">        A uniformly-sampled array of corresponding data/values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Instantiate an array of timestamps with the desired cadence:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">xdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">xdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">xdata</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">xdata</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">uniformXdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="n">cadence</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datetime</span><span class="p">)</span>
    <span class="c1"># Get indices of values nearest to the time array above:</span>
    <span class="n">uniformIndices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniformXdata</span><span class="p">)):</span>
        <span class="n">goodIndex</span><span class="p">,</span> <span class="n">goodValue</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">uniformXdata</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">uniformIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">goodIndex</span> <span class="p">)</span>
    <span class="n">uniformIndicesArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">uniformIndices</span><span class="p">)</span>
    <span class="c1"># Extract the good values:</span>
    <span class="n">uniformYdata</span> <span class="o">=</span> <span class="n">ydata</span><span class="p">[</span><span class="n">uniformIndicesArray</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">uniformXdata</span><span class="p">,</span> <span class="n">uniformYdata</span></div>


<div class="viewcode-block" id="imputeData">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.imputeData">[docs]</a>
<span class="k">def</span> <span class="nf">imputeData</span><span class="p">(</span><span class="n">timestamps</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">bad_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given timeseries data, impute bad values and returned the cleaned data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    timestamps : arraylike</span>
<span class="sd">        A 1D list or array of timestamps.</span>
<span class="sd">    values : arraylike</span>
<span class="sd">        A 1D list or array of timeseries data.</span>
<span class="sd">    method : str</span>
<span class="sd">        A string indicating the method to be used. If &#39;mean&#39;, &#39;median&#39;, &#39;most_frequent&#39;, or &#39;constant&#39;, uses the</span>
<span class="sd">        SimpleImputer routine from sklearn. If &#39;gam&#39;, uses a Generalized Additive Model to fill in the data. If &#39;gpr&#39;,</span>
<span class="sd">        use Gaussian Process Regression to perform imputation. Otherwise, cubic spline interpolation is used for</span>
<span class="sd">        imputation.</span>
<span class="sd">    bad_values : float, int, or NaN (type)</span>
<span class="sd">        The type of the data you wish to impute.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cleanTimes : numpy.ndarray</span>
<span class="sd">        The timestamps corresponding to the cleaned data. This will differ from &#39;timestamps&#39; if and only if some data</span>
<span class="sd">        are necessarily excluded by the chosen imputation method. For example, the edges of the data are often removed</span>
<span class="sd">        when the cubic spline interpolation is used for imputation, to avoid Runge&#39;s phenomenon.</span>
<span class="sd">    cleanData : numpy.ndarray</span>
<span class="sd">        The cleaned 1D timeseries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cleanTimes</span> <span class="o">=</span> <span class="n">timestamps</span>
    <span class="c1"># Replace the bad values with NaNs:</span>
    <span class="k">if</span> <span class="n">bad_values</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">:</span>
        <span class="n">bad_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">values</span><span class="o">==</span><span class="n">bad_values</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">values</span><span class="p">[</span><span class="n">bad_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1"># Use the SimpleImputer routine from sklearn:</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;mean&#39;</span> <span class="ow">or</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;median&#39;</span> <span class="ow">or</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;most_frequent&#39;</span> <span class="ow">or</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;constant&#39;</span><span class="p">:</span>
        <span class="n">imp</span> <span class="o">=</span> <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="n">imp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">cleanData</span> <span class="o">=</span> <span class="n">imp</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;gpr&#39;</span><span class="p">:</span>
        <span class="c1"># TODO: Fix the Gaussian Process approach below so that sensible values are imputed:</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">values</span> <span class="c1"># [100:10000]</span>
        <span class="n">DOYvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fractionalDOY</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">timestamps</span><span class="p">])</span>
        <span class="n">DOYsubset</span> <span class="o">=</span> <span class="n">DOYvals</span> <span class="c1"># [100:10000]</span>
        <span class="kn">from</span> <span class="nn">sklearn.gaussian_process</span> <span class="kn">import</span> <span class="n">GaussianProcessRegressor</span>
        <span class="kn">from</span> <span class="nn">sklearn.gaussian_process.kernels</span> <span class="kn">import</span> <span class="n">RBF</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span><span class="n">length_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">length_scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-3</span><span class="p">,</span> <span class="mf">1e3</span><span class="p">))</span>
        <span class="n">XPred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DOYsubset</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">XAxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">XAxis</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">subset</span><span class="p">)]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">subset</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">gpr</span> <span class="o">=</span> <span class="n">GaussianProcessRegressor</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">yMeanPred</span><span class="p">,</span> <span class="n">yStdPred</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">XAxis</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># plt.figure(); plt.plot(XAxis, yMeanPred, linestyle=&#39;-.&#39;); plt.plot(XAxis, subset); plt.show()</span>
    <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;gam&#39;</span><span class="p">:</span>
        <span class="c1"># Use a GAM to parameterize perform gap-filling:</span>
        <span class="n">DOY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fractionalDOY</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">timestamps</span><span class="p">])</span>
        <span class="kn">from</span> <span class="nn">pygam</span> <span class="kn">import</span> <span class="n">LinearGAM</span><span class="p">,</span> <span class="n">s</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">DOY</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)]</span>
        <span class="n">gam</span> <span class="o">=</span> <span class="n">LinearGAM</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">cleanedData</span> <span class="o">=</span> <span class="n">gam</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">DOY</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)])</span>
        <span class="n">cleanData</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cleanData</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cleanedData</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Clip the ends of the data:</span>
        <span class="n">firstNonNanValue</span><span class="p">,</span> <span class="n">firstNonNanIndex</span> <span class="o">=</span> <span class="n">firstNonNan</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">lastNonNanValue</span><span class="p">,</span> <span class="n">lastNonNanIndex</span> <span class="o">=</span> <span class="n">firstNonNan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">lastNonNanIndex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">-</span> <span class="n">lastNonNanIndex</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">firstNonNanIndex</span><span class="p">:</span><span class="n">lastNonNanIndex</span><span class="p">]</span>
        <span class="n">cleanTimes</span> <span class="o">=</span> <span class="n">timestamps</span><span class="p">[</span><span class="n">firstNonNanIndex</span><span class="p">:</span><span class="n">lastNonNanIndex</span><span class="p">]</span>
        <span class="c1"># Perform the imputation</span>
        <span class="n">XAxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">XAxis</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">subset</span><span class="p">)]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">subset</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">spl</span> <span class="o">=</span> <span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">cleanData</span> <span class="o">=</span> <span class="n">spl</span><span class="p">(</span><span class="n">XAxis</span><span class="p">)</span>
        <span class="c1"># View the results as a sanity check:</span>
        <span class="c1"># plt.figure();</span>
        <span class="c1"># plt.plot(XAxis, cleanData, linestyle=&#39;-.&#39;);</span>
        <span class="c1"># plt.plot(XAxis, subset);</span>
        <span class="c1"># plt.show()</span>

    <span class="c1"># plt.figure(); plt.plot(timestamps, values); plt.plot(cleanTimes, cleanData); plt.show()</span>

    <span class="k">return</span> <span class="n">cleanTimes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">cleanData</span><span class="p">)</span></div>


<div class="viewcode-block" id="gapify">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.gapify">[docs]</a>
<span class="k">def</span> <span class="nf">gapify</span><span class="p">(</span><span class="n">timeseries</span><span class="p">,</span> <span class="n">bad_value</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">replace_val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take a timeseries and replace the bad values (signified by &#39;bad_values&#39;) with NaNs, unless otherwise desired.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    timestamps : arraylike</span>
<span class="sd">        A 1D list or array of timestamps.</span>
<span class="sd">    bad_values : int or float</span>
<span class="sd">        A float or int corresponding to the bad values to be &#39;gapped out&#39;. Default is 999.</span>
<span class="sd">    replace_val : int, float, NaN, or None</span>
<span class="sd">        An int, float, NaN, or Nonetype describing what will replace the bad values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :return gappedData:</span>
<span class="sd">        The gapified 1D data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gappedData</span> <span class="o">=</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">bad_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">gappedData</span> <span class="o">==</span> <span class="n">bad_value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">gappedData</span><span class="p">[</span><span class="n">bad_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">replace_val</span>
    <span class="k">return</span> <span class="n">gappedData</span></div>


<div class="viewcode-block" id="fractionalDOY">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.fractionalDOY">[docs]</a>
<span class="k">def</span> <span class="nf">fractionalDOY</span><span class="p">(</span><span class="n">myDatetime</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a generic datetime object into a float corresponding to the fractional day of the year.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    myDatetime : datetime.datetime</span>
<span class="sd">        A datetime object.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fracDOY : float</span>
<span class="sd">        A float corresponding to the fractional Day of the Year, with the decimal portion included to show contributions</span>
<span class="sd">        from the time of day in hours, minutes, and seconds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fracDOY</span> <span class="o">=</span> <span class="n">myDatetime</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()</span><span class="o">.</span><span class="n">tm_yday</span> <span class="o">+</span> <span class="n">myDatetime</span><span class="o">.</span><span class="n">hour</span><span class="o">/</span><span class="mf">24.</span> <span class="o">+</span> <span class="n">myDatetime</span><span class="o">.</span><span class="n">minute</span><span class="o">/</span><span class="mf">3600.</span> <span class="o">+</span> <span class="n">myDatetime</span><span class="o">.</span><span class="n">second</span><span class="o">/</span><span class="mf">86400.</span>
    <span class="k">return</span> <span class="n">fracDOY</span></div>


<span class="c1"># TODO: Fix the function below to handle VERY LARGE data gaps.</span>
<div class="viewcode-block" id="rollingAverage">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.rollingAverage">[docs]</a>
<span class="k">def</span> <span class="nf">rollingAverage</span><span class="p">(</span><span class="n">myData</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">impute_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Using pandas, compute a rolling average of over &#39;data&#39; using a window length of &#39;windowlength&#39;. Sets the leading and</span>
<span class="sd">    trailing windows to the values of the original data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    myData : arraylike</span>
<span class="sd">        The data over which to compute the rolling average.</span>
<span class="sd">    window_length : int</span>
<span class="sd">        The size of the window over which to average.</span>
<span class="sd">    impute_edges : bool</span>
<span class="sd">        A boolean determining whether the edges will be interpolated. Default is True.</span>
<span class="sd">    center : bool</span>
<span class="sd">        A boolean determining whether the centered average will be used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rolled : arraylike</span>
<span class="sd">        The rolling averaged data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">myDataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">myData</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Var&#39;</span><span class="p">])</span>
    <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window_length</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">firstValidIndex</span> <span class="o">=</span> <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">first_valid_index</span><span class="p">()</span>
    <span class="n">lastValidIndex</span> <span class="o">=</span> <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">impute_edges</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Sample x-axis:</span>
        <span class="n">sampleXaxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">window_length</span><span class="p">,</span> <span class="n">window_length</span><span class="p">)</span>
        <span class="n">middleIndex</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">window_length</span><span class="p">)</span>
        <span class="c1"># Use cubic interpolation to fill the gaps on the edges:</span>
        <span class="c1"># leadingEdgeStartingVal = myDataframe[&#39;Var&#39;][0]</span>
        <span class="c1"># goodLeadingVals = myDataframe[&#39;Var&#39;][:window_length][myDataframe[&#39;Var&#39;][:window_length] &gt; 0]</span>
        <span class="c1"># leadingEdgeStartingVal = np.percentile(goodLeadingVals.values, 25)</span>
        <span class="n">leadingEdgeStartingVal</span> <span class="o">=</span> <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Var&#39;</span><span class="p">][:</span><span class="n">window_length</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">leadingEndingVal</span> <span class="o">=</span> <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">][</span><span class="n">firstValidIndex</span><span class="p">]</span>
        <span class="n">leadingEdgeMiddleVal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">leadingEdgeStartingVal</span><span class="p">,</span> <span class="n">leadingEndingVal</span><span class="p">])</span>
        <span class="n">leadingSpline</span> <span class="o">=</span> <span class="n">CubicSpline</span><span class="p">([</span><span class="n">sampleXaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sampleXaxis</span><span class="p">[</span><span class="n">middleIndex</span><span class="p">],</span> <span class="n">sampleXaxis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                                    <span class="p">[</span><span class="n">leadingEdgeStartingVal</span><span class="p">,</span> <span class="n">leadingEdgeMiddleVal</span><span class="p">,</span> <span class="n">leadingEndingVal</span><span class="p">])</span>
        <span class="n">leadingImputedValues</span> <span class="o">=</span> <span class="n">leadingSpline</span><span class="p">(</span><span class="n">sampleXaxis</span><span class="p">)</span>
        <span class="c1"># plt.figure(); plt.plot(sampleXaxis, myDataframe[&#39;Var&#39;][:window_length].values); plt.plot(sampleXaxis, leadingImputedValues); plt.show()</span>

        <span class="n">trailingEdgeStartingVal</span> <span class="o">=</span> <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">][</span><span class="n">lastValidIndex</span><span class="p">]</span>
        <span class="n">trailingEndingVal</span> <span class="o">=</span> <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">trailingEdgeMiddleVal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">trailingEdgeStartingVal</span><span class="p">,</span> <span class="n">trailingEndingVal</span><span class="p">])</span>
        <span class="n">trailingSpline</span> <span class="o">=</span> <span class="n">CubicSpline</span><span class="p">([</span><span class="n">sampleXaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sampleXaxis</span><span class="p">[</span><span class="n">middleIndex</span><span class="p">],</span> <span class="n">sampleXaxis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                                    <span class="p">[</span><span class="n">trailingEdgeStartingVal</span><span class="p">,</span> <span class="n">trailingEdgeMiddleVal</span><span class="p">,</span> <span class="n">trailingEndingVal</span><span class="p">])</span>
        <span class="n">trailingImputedValues</span> <span class="o">=</span> <span class="n">trailingSpline</span><span class="p">(</span><span class="n">sampleXaxis</span><span class="p">)</span>
        <span class="c1"># plt.figure(); plt.plot(sampleXaxis, myDataframe[&#39;Var&#39;][-window_length:].values); plt.plot(sampleXaxis, trailingImputedValues); plt.show()</span>

        <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">][:</span><span class="n">window_length</span><span class="p">]</span> <span class="o">=</span> <span class="n">leadingImputedValues</span>
        <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">][</span><span class="o">-</span><span class="n">window_length</span><span class="p">:]</span> <span class="o">=</span> <span class="n">trailingImputedValues</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">][:</span><span class="n">window_length</span><span class="p">]</span> <span class="o">=</span> <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Var&#39;</span><span class="p">][:</span><span class="n">window_length</span><span class="p">]</span>
        <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">][</span><span class="o">-</span><span class="n">window_length</span><span class="p">:]</span> <span class="o">=</span> <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Var&#39;</span><span class="p">][</span><span class="o">-</span><span class="n">window_length</span><span class="p">:]</span>
    <span class="n">rolled</span> <span class="o">=</span> <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="k">return</span> <span class="n">rolled</span></div>


<div class="viewcode-block" id="rollingStd">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.rollingStd">[docs]</a>
<span class="k">def</span> <span class="nf">rollingStd</span><span class="p">(</span><span class="n">myData</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some data, compute the rolling standard deviation. If the data is two dimensional, compute the rolling</span>
<span class="sd">    standard deviation along a specific axis of the data (specified by the user).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    myData : arraylike</span>
<span class="sd">        The data over which to compute the rolling average.</span>
<span class="sd">    window_length : int</span>
<span class="sd">        The size of the window over which to average. Default is 2.</span>
<span class="sd">    axis : int</span>
<span class="sd">        For 2D data, the axis along which to compute the rolling standard deviation. Defaults is -1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stdData : numpy.ndarray</span>
<span class="sd">        The rolling standard deviation values of the data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define the generic rolling std function to be used repeatedly:</span>
    <span class="k">def</span> <span class="nf">stdRoller</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">windowLength</span><span class="p">):</span>
        <span class="n">myDataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Var&#39;</span><span class="p">])</span>
        <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">windowLength</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="c1"># Set the leading and trailing values equal to the mean standard deviation:</span>
        <span class="n">meanStd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">infillData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">][:</span><span class="n">windowLength</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">meanStd</span><span class="p">)</span>
        <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">][:</span><span class="n">windowLength</span><span class="p">]</span> <span class="o">=</span> <span class="n">infillData</span>
        <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">][</span><span class="o">-</span><span class="n">windowLength</span><span class="p">:]</span> <span class="o">=</span> <span class="n">infillData</span>
        <span class="n">stdRes</span> <span class="o">=</span> <span class="n">myDataframe</span><span class="p">[</span><span class="s1">&#39;Rolling&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">return</span> <span class="n">stdRes</span>
    <span class="c1"># Perform the computation:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">myData</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Case for unidimensional data:</span>
        <span class="n">stdData</span> <span class="o">=</span> <span class="n">stdRoller</span><span class="p">(</span><span class="n">myData</span><span class="p">,</span> <span class="n">window_length</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Case for 2D data: Iterate through the data along the desired axis:</span>
        <span class="n">stdData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">myData</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># First Axis:</span>
            <span class="k">for</span> <span class="n">iRow</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">myData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">stdData</span><span class="p">[</span><span class="n">iRow</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stdRoller</span><span class="p">(</span><span class="n">myData</span><span class="p">[</span><span class="n">iRow</span><span class="p">,</span> <span class="p">:],</span> <span class="n">window_length</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Second Axis:</span>
            <span class="k">for</span> <span class="n">iCol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">myData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">stdData</span><span class="p">[:,</span> <span class="n">iCol</span><span class="p">]</span> <span class="o">=</span> <span class="n">stdRoller</span><span class="p">(</span><span class="n">myData</span><span class="p">[:,</span> <span class="n">iCol</span><span class="p">],</span> <span class="n">window_length</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The axis specified exceeds the dimensions of the data.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stdData</span></div>


<div class="viewcode-block" id="normalize">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.normalize">[docs]</a>
<span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">myData</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize data with respect to the mean, along the axis specified by the user.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    myData : numpy.ndarray</span>
<span class="sd">        A 1d or 2d array of data.</span>
<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to perform normalization with respect to the mean. Default is -1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    normedData : numpy.ndarray</span>
<span class="sd">        The normalized data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">normFunc</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">myData</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">normedData</span> <span class="o">=</span> <span class="n">normFunc</span><span class="p">(</span><span class="n">myData</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">normedData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">myData</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># First dimension:</span>
            <span class="k">for</span> <span class="n">iRow</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">myData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">normedData</span><span class="p">[</span><span class="n">iRow</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">normFunc</span><span class="p">(</span><span class="n">myData</span><span class="p">[</span><span class="n">iRow</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">elif</span> <span class="n">axis</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">axis</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Second dimension:</span>
            <span class="k">for</span> <span class="n">iCol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">myData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">normedData</span><span class="p">[:,</span> <span class="n">iCol</span><span class="p">]</span> <span class="o">=</span> <span class="n">normFunc</span><span class="p">(</span><span class="n">myData</span><span class="p">[:,</span> <span class="n">iCol</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The axis specified exceeds the dimensions of the data.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">normedData</span></div>


<div class="viewcode-block" id="corrCol">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.corrCol">[docs]</a>
<span class="k">def</span> <span class="nf">corrCol</span><span class="p">(</span><span class="n">myData</span><span class="p">,</span> <span class="n">otherData</span><span class="p">,</span> <span class="n">saveLoc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given two sets of data, find the correlation between them. If the first set of data</span>
<span class="sd">    is multidimensional, correlate it with the second set by column. This function requires that</span>
<span class="sd">    &#39;otherData&#39; is 1D and equivalent to the lengths of the columns of &#39;myData&#39;. Otherwise, if &#39;myData&#39;</span>
<span class="sd">    is 1D, it must be the same length as &#39;otherData&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    myData : numpy.ndarray</span>
<span class="sd">        The dependent variable data.</span>
<span class="sd">    otherData : numpy.ndarray</span>
<span class="sd">        The independent variable data.</span>
<span class="sd">    saveLoc : str</span>
<span class="sd">        A location where to save figures of the correlations. Optional argument. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fitParams : numpy.ndarray</span>
<span class="sd">        A poly1d object for the fit of the data. The last element is Pearson&#39;s R.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Loop through the columns and perform the correlation:</span>
    <span class="n">fitParams</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sortInds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">otherData</span><span class="p">)</span>
    <span class="n">sortedOtherData</span> <span class="o">=</span> <span class="n">otherData</span><span class="p">[</span><span class="n">sortInds</span><span class="p">]</span>
    <span class="n">referenceData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">sortedOtherData</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">sortedOtherData</span><span class="p">),</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">myData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">currentData</span> <span class="o">=</span> <span class="n">myData</span><span class="p">[:,</span> <span class="n">i</span><span class="p">][</span><span class="n">sortInds</span><span class="p">]</span>
        <span class="c1"># Find the best model fit, up to a polynomial of order 10:</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">rss</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">bestPolyfit</span><span class="p">(</span><span class="n">sortedOtherData</span><span class="p">,</span> <span class="n">currentData</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Rval</span> <span class="o">=</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">sortedOtherData</span><span class="p">,</span> <span class="n">currentData</span><span class="p">)</span>
        <span class="c1"># View the data:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">sortedOtherData</span><span class="p">,</span> <span class="n">currentData</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">referenceData</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="n">referenceData</span><span class="p">),</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Model Fit: Order &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; (RSS= &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">rss</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Pearson&#39;s R: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Rval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">text</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$\sigma_{r_{\Theta_{\lambda}}}$&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;F10.7 (sfu)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;$\sigma_{r_{\Theta_{\lambda}}}$ vs. F10.7 (Band &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
        <span class="n">fitParams</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="n">Rval</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">saveLoc</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">saveLoc</span><span class="o">+</span><span class="s1">&#39;neuvacResidStdCorrelation_Band&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Plot saved to &#39;</span><span class="o">+</span><span class="n">saveLoc</span><span class="o">+</span><span class="s1">&#39;neuvacResidStdCorrelation_Band&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fitParams</span></div>


<div class="viewcode-block" id="bestPolyfit">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.bestPolyfit">[docs]</a>
<span class="k">def</span> <span class="nf">bestPolyfit</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">maxOrder</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given independent variable and dependent variable 1D data fit the data with polynomial functions of orders up to a</span>
<span class="sd">    user-defined limit set to &#39;maxOrder&#39;. For the best-fitting model, return the parameters for the polynomial (as a</span>
<span class="sd">    poly1d object) along with the associated Residual Sum of Squares.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xdata : numpy.ndarray</span>
<span class="sd">        1D independent variable data.</span>
<span class="sd">    ydata : numpy.ndarray</span>
<span class="sd">        1D dependent variable data.</span>
<span class="sd">    maxOrder : int</span>
<span class="sd">        A number below which (inclusive) to consider models to fit to the data. Default is 5.</span>
<span class="sd">    func : str</span>
<span class="sd">        Specifies what function should be used for fitting. Valid strings are: &#39;exp&#39;, &#39;linear&#39;, &#39;log&#39;, and &#39;cubic&#39;. If</span>
<span class="sd">        this argument is passed, maxOrder is ignored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    modelRes : list</span>
<span class="sd">        A list where the first element are the model parameters, the second is the Residual Sum of Squares, and the</span>
<span class="sd">        third is the model order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Example functions:</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="s1">&#39;exp&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">myFunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span>
        <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="s1">&#39;cubic&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">myFunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span>
        <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">myFunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">myFunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                <span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">myFunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid argument supplied for argument &quot;func&quot;.&#39;</span><span class="p">)</span>

    <span class="n">models</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rss_vals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">orders</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Fit models of various orders:</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="s1">&#39;exp&#39;</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2e-3</span><span class="p">,</span> <span class="mf">2e-1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">8e-7</span><span class="p">]</span>
            <span class="n">newP0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2e-3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">ydata</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">ydata</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">myFunc</span><span class="p">,</span> <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span>
        <span class="c1"># If convergence is not achieved, try again with new initializing parameters:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">pcov</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">myFunc</span><span class="p">,</span> <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">newP0</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">popt</span>
        <span class="c1"># Plotting for a sanity check:</span>
        <span class="n">sampleXdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">xdata</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">xdata</span><span class="p">),</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="c1"># plt.figure(); plt.scatter(xdata, ydata, color=&#39;b&#39;, label=&#39;Data&#39;); plt.plot(sampleXdata, myFunc(sampleXdata, *popt), &#39;r-&#39;, label=&#39;Fit&#39;)</span>
        <span class="c1"># plt.plot(sampleXdata, myFunc(sampleXdata, *newP0), color=&#39;orange&#39;, linestyle=&#39;--&#39;); plt.legend(loc=&#39;best&#39;)</span>
        <span class="c1"># Compute the R-squared (https://stackoverflow.com/questions/19189362/getting-the-r-squared-value-using-curve-fit):</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">ydata</span> <span class="o">-</span> <span class="n">myFunc</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>
        <span class="n">ss_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">residuals</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ss_tot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">ydata</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ydata</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">r_squared</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">ss_res</span> <span class="o">/</span> <span class="n">ss_tot</span><span class="p">)</span>
        <span class="n">rss_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_squared</span><span class="p">)</span>
        <span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">myFunc</span><span class="p">,</span> <span class="n">p</span><span class="p">])</span>
        <span class="n">modelRes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">myFunc</span><span class="p">,</span> <span class="n">p</span><span class="p">],</span> <span class="n">r_squared</span><span class="p">,</span> <span class="n">func</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxOrder</span><span class="p">):</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
            <span class="n">rss_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">ydata</span> <span class="o">-</span> <span class="n">p</span><span class="p">(</span><span class="n">xdata</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Determine which model worked the best:</span>
        <span class="n">locBest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rss_vals</span><span class="p">))</span>
        <span class="n">modelRes</span> <span class="o">=</span> <span class="p">[</span><span class="n">models</span><span class="p">[</span><span class="n">locBest</span><span class="p">],</span> <span class="n">rss_vals</span><span class="p">[</span><span class="n">locBest</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="n">locBest</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">modelRes</span></div>


<div class="viewcode-block" id="binRMSE">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.binRMSE">[docs]</a>
<span class="k">def</span> <span class="nf">binRMSE</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydataEst</span><span class="p">,</span> <span class="n">ydataTrue</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">saveLoc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">titleStr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some 1D independent variable data, some 1D estimates of dependent variable data, 1D true values of dependent</span>
<span class="sd">    variable data, and a step size, divide the xdata into bins of width equal to the step size and compute the RMSE</span>
<span class="sd">    error in each bin. Then compute the correlation between the RMSE and the binned xdata. Automatically saves</span>
<span class="sd">    a figure for the results at a user-defined location.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xdata: numpy.ndarray</span>
<span class="sd">        1D independent variable data.</span>
<span class="sd">    ydataEst: numpy.ndarray</span>
<span class="sd">        1D estimates of dependent variable data.</span>
<span class="sd">    ydataEst : numpy.ndarray</span>
<span class="sd">        1D actual values of dependent variable data.</span>
<span class="sd">    step : int</span>
<span class="sd">        The bin width for the independent variable data. Default is 10.</span>
<span class="sd">    saveLoc : str</span>
<span class="sd">        A string for the location where the figure should be saved.</span>
<span class="sd">    titleStr : str</span>
<span class="sd">        A string for the title of the figure to be generated. Assumes that a single number representing a figure number</span>
<span class="sd">        or wavelength is given.</span>
<span class="sd">    normalize : Bool</span>
<span class="sd">        Controls whether the RMSE is normalized or not. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    binCenters : list</span>
<span class="sd">        The bin centers for the dependent variable data.</span>
<span class="sd">    RMSE : list</span>
<span class="sd">        The RMSE values for each bin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create the bins:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">round_mult</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">xdata</span><span class="p">),</span> <span class="n">step</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;down&#39;</span><span class="p">)</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">round_mult</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">xdata</span><span class="p">),</span> <span class="n">step</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">)</span>
    <span class="n">binCenters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bins</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])])</span>
    <span class="c1"># Loop the bins and compute the RMSE values:</span>
    <span class="n">RMSE</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">binCenters</span><span class="p">:</span>
        <span class="c1"># Isolate the data that correspond to the given bin:</span>
        <span class="n">goodInds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">xdata</span> <span class="o">&gt;=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xdata</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">goodInds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">goodEstData</span> <span class="o">=</span> <span class="n">ydataEst</span><span class="p">[</span><span class="n">goodInds</span><span class="p">]</span>
            <span class="n">goodTrueData</span> <span class="o">=</span> <span class="n">ydataTrue</span><span class="p">[</span><span class="n">goodInds</span><span class="p">]</span>
            <span class="n">rmse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">goodTrueData</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">goodTrueData</span><span class="p">)],</span> <span class="n">goodEstData</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">goodTrueData</span><span class="p">)],</span> <span class="n">squared</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">normalize</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">rmse</span> <span class="o">=</span> <span class="n">rmse</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">goodTrueData</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">goodTrueData</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If there is nothing in the bin, just record NaN for that bin:</span>
            <span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">RMSE</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rmse</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Plot the results for a sanity check:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">binCenters</span><span class="p">,</span> <span class="n">RMSE</span><span class="p">,</span> <span class="s1">&#39;bo-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;F10.7 (sfu)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;RMSE (W/m$^2$/nm)&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">titleStr</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;RMSE vs. F10.7: &#39;</span><span class="o">+</span><span class="n">titleStr</span><span class="o">+</span><span class="s1">&#39; Angstroms&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">saveLoc</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">saveLoc</span><span class="o">+</span><span class="s1">&#39;RootMeanSquareDeviationVsF107_&#39;</span><span class="o">+</span><span class="n">titleStr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">binCenters</span><span class="p">,</span> <span class="n">RMSE</span></div>


<div class="viewcode-block" id="binCorrelation">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.binCorrelation">[docs]</a>
<span class="k">def</span> <span class="nf">binCorrelation</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydataEst</span><span class="p">,</span> <span class="n">ydataTrue</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">saveLoc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">titleStr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some 1D independent variable data, some 1D estimates of dependent variable data, 1D true values of dependent</span>
<span class="sd">    variable data, and a step size, divide the xdata into bins of width equal to the step size and compute the squared</span>
<span class="sd">    difference in each bin. Then compute the correlation between the the squared difference and the binned xdata.</span>
<span class="sd">    Automatically saves a figure for the results at a user-defined location.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xdata : numpy.ndarray</span>
<span class="sd">        1D independent variable data.</span>
<span class="sd">    ydataEst : numpy.ndarray</span>
<span class="sd">        1D estimates of dependent variable data.</span>
<span class="sd">    ydataEst : numpy.ndarray</span>
<span class="sd">        1D actual values of dependent variable data.</span>
<span class="sd">    step : int</span>
<span class="sd">        The bin width for the independent variable data. Default is 10.</span>
<span class="sd">    saveLoc : str</span>
<span class="sd">        A string for the location where the figure should be saved.</span>
<span class="sd">    titleStr : str</span>
<span class="sd">        A string for the title of the figure to be generated. Assumes that a single number representing a figure number</span>
<span class="sd">        or wavelength is given.</span>
<span class="sd">    root : Bool</span>
<span class="sd">        Controls whether the square root of the SQDF is taken. Default is False.</span>
<span class="sd">    normalize : Bool</span>
<span class="sd">        Controls whether the SQDF is normalized (by dividing by the true data and multiplying by 100). Default is False.</span>
<span class="sd">        If True, ignores the value of &#39;root&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    binCenters : list</span>
<span class="sd">        The bin centers for the dependent variable data.</span>
<span class="sd">    SQDF : list</span>
<span class="sd">        The Squared Difference values for each bin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create the bins:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">round_mult</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">xdata</span><span class="p">),</span> <span class="n">step</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;down&#39;</span><span class="p">)</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">round_mult</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">xdata</span><span class="p">),</span> <span class="n">step</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">)</span>
    <span class="n">binCenters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bins</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])])</span>
    <span class="c1"># Loop the bins and compute the RMSE values:</span>
    <span class="n">SQDF</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">binCenters</span><span class="p">:</span>
        <span class="c1"># Isolate the data that correspond to the given bin:</span>
        <span class="n">goodInds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">xdata</span> <span class="o">&gt;=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xdata</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">goodInds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">goodEstData</span> <span class="o">=</span> <span class="n">ydataEst</span><span class="p">[</span><span class="n">goodInds</span><span class="p">]</span>
            <span class="n">goodTrueData</span> <span class="o">=</span> <span class="n">ydataTrue</span><span class="p">[</span><span class="n">goodInds</span><span class="p">]</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">goodTrueData</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">goodTrueData</span><span class="p">)])</span>
            <span class="n">sqdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">goodEstData</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">goodTrueData</span><span class="p">)],</span> <span class="n">goodTrueData</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">goodTrueData</span><span class="p">)]))</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
            <span class="n">ylabelString</span> <span class="o">=</span> <span class="s1">&#39;Squared Differences (W/m$^2$/nm)&#39;</span>
            <span class="n">realTitleString</span> <span class="o">=</span> <span class="s1">&#39;Squared Differences&#39;</span>
            <span class="k">if</span> <span class="n">normalize</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">sqdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sqdf</span><span class="p">)</span>
                    <span class="n">ylabelString</span> <span class="o">=</span> <span class="s1">&#39;RMSE (W/m$^2$/nm)&#39;</span>
                    <span class="n">realTitleString</span> <span class="o">=</span> <span class="s1">&#39;RMSE&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sqdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">goodEstData</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">goodTrueData</span><span class="p">)],</span> <span class="n">goodTrueData</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">goodTrueData</span><span class="p">)])),</span>
                    <span class="n">goodTrueData</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">goodTrueData</span><span class="p">)])</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
                <span class="n">ylabelString</span> <span class="o">=</span> <span class="s1">&#39;Normalized RMSE (W/m$^2$/nm)&#39;</span>
                <span class="n">realTitleString</span> <span class="o">=</span> <span class="s1">&#39;Normalized RMSE&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If there is nothing in the bin, just record NaN for that bin:</span>
            <span class="n">sqdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">SQDF</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sqdf</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Plot the results for a sanity check:</span>
    <span class="n">titleFontSize</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">fontSize</span> <span class="o">=</span> <span class="mi">18</span>
    <span class="n">labelSize</span> <span class="o">=</span> <span class="mi">16</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">binCenters</span><span class="p">,</span> <span class="n">SQDF</span><span class="p">,</span> <span class="s1">&#39;mo-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;F10.7 (sfu)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontSize</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylabelString</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontSize</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="n">labelSize</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">titleStr</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">realTitleString</span><span class="o">+</span><span class="s1">&#39; vs. F10.7: &#39;</span><span class="o">+</span><span class="n">titleStr</span><span class="o">+</span><span class="s1">&#39; Angstroms&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">titleFontSize</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">saveLoc</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">saveLoc</span><span class="o">+</span><span class="n">realTitleString</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;vsF107_&#39;</span><span class="o">+</span><span class="n">titleStr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">binCenters</span><span class="p">,</span> <span class="n">SQDF</span></div>


<div class="viewcode-block" id="round_mult">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.round_mult">[docs]</a>
<span class="k">def</span> <span class="nf">round_mult</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">divisor</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;down&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Round a number to the nearest integer multiple of a given divisor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num: int or float</span>
<span class="sd">        The number to round down.</span>
<span class="sd">    divisor: int or float</span>
<span class="sd">        The number which the result must be an integer multiple of.</span>
<span class="sd">    direction: str</span>
<span class="sd">        Either &#39;down&#39; or &#39;up&#39;. Specifies whether rounding should be done up or down/</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rounded: float</span>
<span class="sd">        The resulting number.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;down&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">-</span> <span class="p">(</span><span class="n">num</span><span class="o">%</span><span class="n">divisor</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">divisor</span><span class="o">*</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">num</span><span class="o">/</span><span class="n">divisor</span><span class="p">))</span></div>


<div class="viewcode-block" id="stringList">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.stringList">[docs]</a>
<span class="k">def</span> <span class="nf">stringList</span><span class="p">(</span><span class="n">myList</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a list of numbers into a single string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    myList : list</span>
<span class="sd">        A list of numbers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    myStr : str</span>
<span class="sd">        The string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">strList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">myList</span><span class="p">]</span>
    <span class="n">myStr</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strList</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">myStr</span></div>


<div class="viewcode-block" id="rebin">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.rebin">[docs]</a>
<span class="k">def</span> <span class="nf">rebin</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rebin 2D [irradiance/flux] data, where each row is a complete spectrum, and each column is a specific wavelength</span>
<span class="sd">    bin. Do the rebinning according to a desired resolution, and restrict the returned information to wavelength</span>
<span class="sd">    boundaries set by the user.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wavelengths : arraylike</span>
<span class="sd">        A list of wavelengths at which each irradiance value is taken.</span>
<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        A 2D array of spectrum data (irradiances or fluxes).</span>
<span class="sd">    resolution : float or dict</span>
<span class="sd">        The desired spectral resolution of the rebinned data. Units must be in nanometers. If argument is a dict, the</span>
<span class="sd">        key &#39;short&#39; should contain wavelength boundaries for the beginning of bins, and the key &#39;long&#39; should contain</span>
<span class="sd">        wavelength boundaries for the ending of bins. These boundaries should be in Angstroms.</span>
<span class="sd">    limits : list</span>
<span class="sd">        A list of two elements, where the first is a lower limit for wavelengths and the second is an upper limit for</span>
<span class="sd">        wavelengths, both in units of nanometers.</span>
<span class="sd">    factor : int</span>
<span class="sd">        A factor by which to upsample the data before performing rebinning. Tends to make the binning much more</span>
<span class="sd">        accurate, due to the use of integrals. Default is None.</span>
<span class="sd">    zero : bool</span>
<span class="sd">        Controls whether singular lines are set to a value of zero after they are extracted. Default is True.</span>
<span class="sd">    unc : bool</span>
<span class="sd">        Indicates whether or not uncertainties are being rebinned. If so, they will be combined in each bin using an</span>
<span class="sd">        interpolation method.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    newWaves : numpy.ndarray</span>
<span class="sd">        The centers of the wavelength bins corresponding to the rebinned data.</span>
<span class="sd">    newData : numpy.ndarray</span>
<span class="sd">        The rebinned data as a 2D array, arranged like the input data but at the new wavelength resolution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the native wavelength resolution of the input data:</span>
    <span class="n">nativeResolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">nativeWavelengths</span> <span class="o">=</span> <span class="n">wavelengths</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Upsample the wavelengths and irradiance data so that integrals are more accurate:</span>
    <span class="k">if</span> <span class="n">factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="n">wavelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wavelengths</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">factor</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Replace all NaNs with zeros:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp2d</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="n">wavelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wavelengths</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">factor</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">obs</span><span class="p">)</span>

    <span class="c1"># For uncertainty quantification, interpolate the grid of uncertainty values:</span>
    <span class="k">if</span> <span class="n">unc</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># d_vals = data.flatten()</span>
        <span class="c1"># x_vals = np.repeat(wavelengths, int(d_vals.shape[0] / wavelengths.shape[0]))</span>
        <span class="c1"># numrows = data.shape[0]</span>
        <span class="c1"># y_vals = np.asarray([np.repeat(element, data.shape[1]) for element in np.linspace(0, numrows-1, numrows)]).flatten()</span>
        <span class="c1"># rbf_fun = Rbf(x_vals, y_vals, d_vals)</span>
        <span class="n">newWaves</span> <span class="o">=</span> <span class="n">wavelengths</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="n">mids</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">resolution</span><span class="p">[</span><span class="s1">&#39;long&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">resolution</span><span class="p">[</span><span class="s1">&#39;short&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">newWaves</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="n">newData</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">mids</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp2d</span><span class="p">(</span><span class="n">newWaves</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="n">newData</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">mids</span><span class="p">,</span> <span class="n">obs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Loop through each row the new data array, and fill it in with the rebinned data:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="c1"># TODO: The code for this if cell is VERY SLOW when processing large arrays. It needs to be sped up.</span>
            <span class="c1"># CONDITION FOR A SINGLE WAVELENGTH RESOLUTION.</span>
            <span class="c1"># Compute the wavelength centers for the new bins:</span>
            <span class="k">if</span> <span class="n">limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">newWaves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">))</span>
                <span class="n">newWaves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wavelengths</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">step</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="c1"># Instantiate the new data array:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">newData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">newWaves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">newWaves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="c1"># Loop over each spectrum (each individual observation):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">newData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="c1"># Loop through the wavelength intervals:</span>
                <span class="n">currentSpectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">newWaves</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">newWaves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># Get the indices of elements in each wavelength bin - ASSUME that the original data are associated with</span>
                    <span class="c1"># bin centers - apply an offset equal to the respective interval of the bin:</span>
                    <span class="n">binInds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">wavelengths</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">newWaves</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">resolution</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wavelengths</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">newWaves</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">resolution</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># Gather the elements in the bin and multiply them by the respective native bin width:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">binElements</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">binInds</span><span class="p">]</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">binElements</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">binInds</span><span class="p">]</span>

                    <span class="n">binWidths</span> <span class="o">=</span> <span class="n">nativeResolution</span><span class="p">[</span><span class="n">binInds</span><span class="p">]</span>
                    <span class="n">binProducts</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">binElements</span><span class="p">,</span> <span class="n">binWidths</span><span class="p">)]</span>
                    <span class="c1"># Take the sum:</span>
                    <span class="n">binSum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binProducts</span><span class="p">)</span>

                    <span class="c1"># Integrate the bin:</span>
                    <span class="n">binVal</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">binElements</span><span class="p">,</span> <span class="n">wavelengths</span><span class="p">[</span><span class="n">binInds</span><span class="p">])</span>
                    <span class="c1"># binVal = binSum/(2*resolution)</span>

                    <span class="c1"># Add the value to the current spectrum:</span>
                    <span class="n">currentSpectrum</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">binVal</span>

                <span class="c1"># Once a single spectrum is obtained, add it to the new data array:</span>
                <span class="n">newData</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">currentSpectrum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># CONDITION FOR A BINNING WITH UNIQUE BIN WIDTHS.</span>
            <span class="n">shorts</span> <span class="o">=</span> <span class="n">resolution</span><span class="p">[</span><span class="s1">&#39;short&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">10.</span>
            <span class="n">longs</span> <span class="o">=</span> <span class="n">resolution</span><span class="p">[</span><span class="s1">&#39;long&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">10.</span>
            <span class="n">newWaves</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">shorts</span> <span class="o">+</span> <span class="n">longs</span><span class="p">)</span>

            <span class="c1"># Instantiate the new data array:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">newData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">newWaves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">newWaves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="c1"># First go through all of the wavelengths that are singular</span>
            <span class="n">myData</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">for</span> <span class="n">iWave</span><span class="p">,</span> <span class="n">short</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shorts</span><span class="p">):</span>
                <span class="n">long</span> <span class="o">=</span> <span class="n">longs</span><span class="p">[</span><span class="n">iWave</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">long</span> <span class="o">==</span> <span class="n">short</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wavelengths</span> <span class="o">-</span> <span class="n">short</span><span class="p">))</span>
                    <span class="n">i2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">nativeWavelengths</span> <span class="o">-</span> <span class="n">short</span><span class="p">))</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">newData</span><span class="p">[:,</span> <span class="n">iWave</span><span class="p">]</span> <span class="o">=</span> <span class="n">myData</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">nativeWavelengths</span><span class="p">[</span><span class="n">i2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nativeWavelengths</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">newData</span><span class="p">[:,</span> <span class="n">iWave</span><span class="p">]</span> <span class="o">=</span> <span class="n">myData</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">nativeWavelengths</span><span class="p">[</span><span class="n">i2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nativeWavelengths</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">zero</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="c1"># Zero out bin so we don&#39;t double count it.</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">myData</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">myData</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">myData</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Then go through the ranges</span>
            <span class="k">for</span> <span class="n">iWave</span><span class="p">,</span> <span class="n">short</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shorts</span><span class="p">):</span>
                <span class="n">long</span> <span class="o">=</span> <span class="n">longs</span><span class="p">[</span><span class="n">iWave</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">long</span> <span class="o">!=</span> <span class="n">short</span><span class="p">):</span>
                    <span class="n">d1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wavelengths</span> <span class="o">-</span> <span class="n">short</span><span class="p">)</span>
                    <span class="n">iStart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>
                    <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wavelengths</span> <span class="o">-</span> <span class="n">long</span><span class="p">)</span>
                    <span class="n">iEnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span>
                    <span class="n">wave_int</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="c1"># For wavelengths at or below 0.2 nm, just compute the sum:</span>
                    <span class="k">if</span> <span class="n">long</span> <span class="o">&lt;=</span> <span class="mf">0.2</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iStart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iEnd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="n">newData</span><span class="p">[:,</span> <span class="n">iWave</span><span class="p">]</span> <span class="o">+=</span> <span class="n">myData</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> \
                                                 <span class="p">(</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">wavelengths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="n">wave_int</span> <span class="o">+=</span> <span class="p">(</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">wavelengths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">newData</span><span class="p">[:,</span> <span class="n">iWave</span><span class="p">]</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">myData</span><span class="p">[:,</span> <span class="n">iStart</span><span class="p">:</span><span class="n">iEnd</span><span class="p">],</span> <span class="n">wavelengths</span><span class="p">[</span><span class="n">iStart</span><span class="p">:</span><span class="n">iEnd</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">newData</span><span class="p">[:,</span> <span class="n">iWave</span><span class="p">]</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">myData</span><span class="p">[</span><span class="n">iStart</span><span class="p">:</span><span class="n">iEnd</span><span class="p">],</span> <span class="n">wavelengths</span><span class="p">[</span><span class="n">iStart</span><span class="p">:</span><span class="n">iEnd</span><span class="p">])</span>

                        <span class="c1"># # Plotting for a sanity check:</span>
                        <span class="c1"># plt.figure();</span>
                        <span class="c1"># plt.plot(wavelengths[iStart:iEnd], myData[iStart:iEnd], marker=&#39;o&#39;)</span>
                        <span class="c1"># plt.scatter(newWaves[iWave], newData[:, iWave])</span>

                    <span class="c1"># for i in range(iStart + 1, iEnd + 1):</span>
                    <span class="c1">#     binWidths = nativeResolution[iStart + 1:iEnd + 1]</span>
                    <span class="c1">#     try:</span>
                    <span class="c1">#         binProducts = [a * b for a, b in zip(myData[:, i], binWidths)]</span>
                    <span class="c1">#         binSum = np.sum(binProducts)</span>
                    <span class="c1">#         newData[:, iWave] = binSum / (iEnd - iStart)</span>
                    <span class="c1">#         # newData[:, iWave] += myData[:, i]  / (iEnd - iStart) # * (wavelengths[i + 1] - wavelengths[i])</span>
                    <span class="c1">#     except:</span>
                    <span class="c1">#         binProducts = [a * b for a, b in zip([myData[i]], binWidths)]</span>
                    <span class="c1">#         binSum = np.sum(binProducts)</span>
                    <span class="c1">#         newData[:, iWave] = binSum / (iEnd - iStart)</span>
                    <span class="c1">#         # newData[:, iWave] += (myData[i] * () )/ (iEnd - iStart)</span>
                    <span class="c1">#     wave_int += (wavelengths[i + 1] - wavelengths[i])</span>

    <span class="c1"># If only a single spectrum was generated, remove the singleton dimension:</span>
    <span class="k">if</span> <span class="n">newData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">newData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">newData</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">newWaves</span><span class="p">,</span> <span class="n">newData</span></div>


<div class="viewcode-block" id="newbins">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.newbins">[docs]</a>
<span class="k">def</span> <span class="nf">newbins</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">zero</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rebin data according to a user-defined binning scheme.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wavelengths : arraylike</span>
<span class="sd">        The wavelengths of the native data. Units should be in nm.</span>
<span class="sd">    data : arraylike</span>
<span class="sd">        The native data to be rebinned. Assumes each row is an observation and each column is a bin.</span>
<span class="sd">    bins : dict</span>
<span class="sd">        A dictionary containing the left-ward wavelength bin limits (first key) and the right-ward wavelength bin limits</span>
<span class="sd">        (right key). Units should be in Angstroms.</span>
<span class="sd">    zero : bool</span>
<span class="sd">        Controls whether a wavelength bin is &#39;zeroed&#39; out after it is considered. Default is False.</span>
<span class="sd">    interpolation : bool</span>
<span class="sd">        Controls whether interpolation or 4-nm centered windowed averaging is used to handle singular emission</span>
<span class="sd">        lines. Default is False, corresponding to the windowed averaging.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    newWaves : arraylike</span>
<span class="sd">        The wavelength boundaries of the new binning scheme.</span>
<span class="sd">    newData : arraylike</span>
<span class="sd">        The values of the rebinned data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># originalData = data</span>
    <span class="n">nativeBinWidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">lowBins</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="s1">&#39;short&#39;</span><span class="p">]</span>
    <span class="n">highBins</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="s1">&#39;long&#39;</span><span class="p">]</span>
    <span class="n">newData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">lowBins</span><span class="p">)))</span>
    <span class="n">newWaves</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">lowBins</span> <span class="o">+</span> <span class="n">highBins</span><span class="p">)</span>
    <span class="c1"># Relevant line indices in FISM2:</span>
    <span class="n">fismLines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">284</span><span class="p">,</span> <span class="mi">303</span><span class="p">,</span> <span class="mi">304</span><span class="p">,</span> <span class="mi">368</span><span class="p">,</span> <span class="mi">465</span><span class="p">,</span> <span class="mi">554</span><span class="p">,</span> <span class="mi">584</span><span class="p">,</span> <span class="mi">609</span><span class="p">,</span> <span class="mi">629</span><span class="p">,</span> <span class="mi">703</span><span class="p">,</span> <span class="mi">765</span><span class="p">,</span> <span class="mi">770</span><span class="p">,</span> <span class="mi">787</span><span class="p">,</span> <span class="mi">976</span><span class="p">,</span> <span class="mi">1025</span><span class="p">,</span> <span class="mi">1031</span><span class="p">,</span> <span class="mi">1215</span><span class="p">])</span>

    <span class="c1"># Loop through the desired wavelengths:</span>
    <span class="n">halfWindow</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">singulars</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lowBins</span><span class="p">)):</span> <span class="c1"># 32</span>
        <span class="c1"># Go through the singular wavelengths first.</span>
        <span class="k">if</span> <span class="n">lowBins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">highBins</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="c1"># idx, val = find_nearest(wavelengths, lowBins[i] / 10.)</span>

            <span class="c1"># Simply assign the values at that index to the new bin values:</span>
            <span class="c1"># newData[:, i] = data[:, fismLines[j]] * nativeBinWidth</span>

            <span class="k">if</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># Sum the data in a 0.4-nm window centered on the line:</span>
                <span class="n">newData</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">halfWindow</span><span class="p">:</span><span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">halfWindow</span><span class="p">]</span> <span class="o">*</span> <span class="n">nativeBinWidth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Aaronic method:</span>
                <span class="c1"># 1: Linearly-interpolate between the adjacent bins to approximate the background value</span>
                <span class="n">interpolatedValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">wavelengths</span><span class="p">[</span><span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">interpVal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">interpolatedValues</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpVal</span>

                <span class="c1"># 2: Take the difference between the native FISM2 bin value and interpolated value</span>
                <span class="n">difference</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="n">interpolatedValues</span>

                <span class="c1"># 3: Assign the difference as the line irradiance (increase in brightness above background)</span>
                <span class="n">newData</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">difference</span> <span class="o">*</span> <span class="n">nativeBinWidth</span>

                <span class="c1"># 4: Sanity check - view the results:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">y</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">y</span><span class="o">=</span><span class="n">interpolatedValues</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">y</span><span class="o">=</span><span class="n">difference</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>

            <span class="n">singulars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lowBins</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># Performing zeroing, if desired:</span>
            <span class="k">if</span> <span class="n">zero</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># data[:, fismLines[j]] = np.zeros_like(data[:, fismLines[j]])</span>
                <span class="k">if</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[:,</span> <span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">halfWindow</span><span class="p">:</span><span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">halfWindow</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">halfWindow</span><span class="p">:</span><span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">halfWindow</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[:,</span> <span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">fismLines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># plt.figure(); plt.plot(wavelengths*10, originalData[0, :], &#39;bo-&#39;); plt.plot(wavelengths*10, data[0, :], &#39;ro-&#39;)</span>
    <span class="c1"># for j in range(len(singulars)):</span>
    <span class="c1">#     plt.axvline(x=singulars[j], color=&#39;k&#39;)</span>
    <span class="c1"># plt.plot(newWaves, newData[0, :], &#39;go-&#39;)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lowBins</span><span class="p">)):</span>
        <span class="c1"># Go through the wavelength ranges:</span>
        <span class="k">if</span> <span class="n">lowBins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">highBins</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="c1"># binWidth = (highBins[i] - lowBins[i])/10.</span>
            <span class="c1"># Isolate the wavelength bands to sum together:</span>
            <span class="n">validInds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">wavelengths</span> <span class="o">&gt;=</span> <span class="n">lowBins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mf">10.</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wavelengths</span> <span class="o">&lt;</span> <span class="n">highBins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mf">10.</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Sum the values in the bins:</span>
            <span class="n">newData</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">validInds</span><span class="p">]</span> <span class="o">*</span> <span class="n">nativeBinWidth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">newWaves</span><span class="p">,</span> <span class="n">newData</span></div>


<div class="viewcode-block" id="forecast">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.forecast">[docs]</a>
<span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">trend_coefs</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Produce linear minimum MSE forecast [taken from statsmodels.tsa.vector_ar.var_model.py]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        Input data. (k_ar x neqs)</span>
<span class="sd">    coefs : numpy.ndarray</span>
<span class="sd">        Coefficients for the model. (k_ar x neqs x neqs)</span>
<span class="sd">    trend_coefs : ndarray (1 x neqs) or (neqs)</span>
<span class="sd">        Coefficients for the trend component. (1 x neqs) or (neqs)</span>
<span class="sd">    steps : int</span>
<span class="sd">        Number of forecasts to make.</span>
<span class="sd">    exog : numpy.ndarray</span>
<span class="sd">        Exogeneous (external) covariates to use during forecasting. (trend_coefs.shape[1] x neqs)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    forecasts : numpy.ndarray</span>
<span class="sd">        Predictions. (steps x neqs)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Lütkepohl p. 37</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;y must by have at least order (</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">) observations. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
    <span class="c1"># initial value</span>
    <span class="n">forcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">trend_coefs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">forcs</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">trend_coefs</span><span class="p">)</span>
    <span class="c1"># to make existing code (with trend_coefs=intercept and without exog) work:</span>
    <span class="k">elif</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">trend_coefs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">forcs</span> <span class="o">+=</span> <span class="n">trend_coefs</span>

    <span class="c1"># h=0 forecast should be latest observation</span>
    <span class="c1"># forcs[0] = y[-1]</span>

    <span class="c1"># make indices easier to think about</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># y_t(h) = intercept + sum_1^p A_i y_t_(h-i)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">forcs</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># slightly hackish</span>
            <span class="k">if</span> <span class="n">h</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># e.g. when h=1, h-1 = 0, which is y[-1]</span>
                <span class="n">prior_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># e.g. when h=2, h-1=1, which is forcs[0]</span>
                <span class="n">prior_y</span> <span class="o">=</span> <span class="n">forcs</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># i=1 is coefs[0]</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coefs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">prior_y</span><span class="p">)</span>

        <span class="n">forcs</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>

    <span class="k">return</span> <span class="n">forcs</span></div>


<div class="viewcode-block" id="forecastInversion">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.forecastInversion">[docs]</a>
<span class="k">def</span> <span class="nf">forecastInversion</span><span class="p">(</span><span class="n">forecastData</span><span class="p">,</span> <span class="n">history</span><span class="p">,</span> <span class="n">lastDiff</span><span class="p">,</span> <span class="n">trend</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Designed to operate on the output of the statsmodels VAR package. Takes a forecast generated by a VAR model, and</span>
<span class="sd">    for each sample in the forecast, inverts the forecast to obtain the actual prediction. Essentially, this function</span>
<span class="sd">    takes forecasts generated for non-stationary data that has been transformed to stationary data, and inverts it</span>
<span class="sd">    in order to give the non-stationary forecast result.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    forecastData : numpy.ndarray</span>
<span class="sd">        An n x m array of forecasts, where n is the number of forecasts and m is the variable.</span>
<span class="sd">    history : numpy.ndarray</span>
<span class="sd">        A 2D array of training data which was used to generate the forecastData.</span>
<span class="sd">    lastDiff : numpy.ndarray</span>
<span class="sd">        A 1 x m array of the most recent differences for all of the variables.</span>
<span class="sd">    trend : numpy.ndarray</span>
<span class="sd">        An 2D array of historical trend data for the non-stationary version of the data.</span>
<span class="sd">    window : int</span>
<span class="sd">        The window over which the historical trend was calculated (assumes some sort of centered average was done).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    invertedForecastDataNew : numpy.ndarray</span>
<span class="sd">        The inverted forecasted data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data_and_preds_combined</span> <span class="o">=</span> <span class="n">history</span>
    <span class="n">invertedForecastData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">forecastData</span><span class="p">)</span>
    <span class="c1"># Loop over the number of samples:</span>
    <span class="n">firstInversions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">forecastData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># Undoing the differencing:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">firstInv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">forecastData</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">lastDiff</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">currentDiff</span> <span class="o">=</span> <span class="n">firstInversions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">firstInv</span>
            <span class="n">firstInv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">forecastData</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">currentDiff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">currentDiff</span> <span class="o">=</span> <span class="n">firstInversions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">firstInversions</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">firstInv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">forecastData</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">currentDiff</span><span class="p">)</span>
        <span class="n">firstInversions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">firstInv</span><span class="p">)</span>

        <span class="c1"># Adding back on the trend</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">secondInv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">firstInv</span><span class="p">,</span> <span class="n">trend</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">currentTrend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data_and_preds_combined</span><span class="p">[</span><span class="o">-</span><span class="n">window</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">secondInv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">firstInv</span><span class="p">,</span> <span class="n">currentTrend</span><span class="p">)</span>
        <span class="c1"># Enforce positive definiteness:</span>
        <span class="n">secondInv</span><span class="p">[</span><span class="n">secondInv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">invertedForecastData</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">secondInv</span>
        <span class="n">data_and_preds_combined</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">data_and_preds_combined</span><span class="p">,</span> <span class="n">invertedForecastData</span><span class="p">])</span>

    <span class="n">base</span> <span class="o">=</span> <span class="n">history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">invertedForecastData</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">base</span><span class="p">)</span>
    <span class="n">invertedForecastDataNew</span> <span class="o">=</span> <span class="n">invertedForecastData</span> <span class="o">-</span> <span class="n">offset</span>

    <span class="c1"># firstX = np.linspace(0, 26617, 26618)</span>
    <span class="c1"># secondX = np.linspace(26617, 26621, 5)</span>
    <span class="c1"># plt.figure()</span>
    <span class="c1"># plt.plot(firstX, history[:, 5])</span>
    <span class="c1"># plt.plot(secondX, invertedForecastDataNew[:, 5])</span>

    <span class="k">return</span> <span class="n">invertedForecastDataNew</span></div>


<div class="viewcode-block" id="find_exp">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.find_exp">[docs]</a>
<span class="k">def</span> <span class="nf">find_exp</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    number : float</span>
<span class="sd">        A float of any precision.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base10</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">base10</span><span class="p">)))</span></div>


<div class="viewcode-block" id="get_cc">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.get_cc">[docs]</a>
<span class="k">def</span> <span class="nf">get_cc</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the cross-correlation of two 1D arrays of the same length.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array1 : numpy.ndarray</span>
<span class="sd">        A 1D array of length n.</span>
<span class="sd">    array2: numpy.ndarray</span>
<span class="sd">        A 1D array of length n.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    c : float</span>
<span class="sd">        The normalized correlation of the two arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">array1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">array1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">array1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">array1</span><span class="p">))</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">array2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">array2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">array2</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span></div>


<div class="viewcode-block" id="mycorrelate2d">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.mycorrelate2d">[docs]</a>
<span class="k">def</span> <span class="nf">mycorrelate2d</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the correlation matrix from 2D data, where each row is cross correlated with the others.</span>
<span class="sd">    This function handles NaN values by ignoring them.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : numpy.ndarray</span>
<span class="sd">        A 2D array of dimensions n x m.</span>
<span class="sd">    normalized : bool</span>
<span class="sd">        Determines whether the resulting correlation matrix is normalized. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ccm : numpy.ndarray</span>
<span class="sd">        The [normalized] cross-correlation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize cross correlation matrix with zeros</span>
    <span class="n">ccm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="c1"># Fill in each entry of the matrix one-by-one:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">outer_row</span> <span class="o">=</span> <span class="n">df</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">inner_row</span> <span class="o">=</span> <span class="n">df</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">goodInds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">outer_row</span><span class="p">),</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">inner_row</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">normalized</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">outer_row</span><span class="p">[</span><span class="n">goodInds</span><span class="p">],</span> <span class="n">inner_row</span><span class="p">[</span><span class="n">goodInds</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">get_cc</span><span class="p">(</span><span class="n">outer_row</span><span class="p">[</span><span class="n">goodInds</span><span class="p">],</span> <span class="n">inner_row</span><span class="p">[</span><span class="n">goodInds</span><span class="p">])</span>
                <span class="c1"># a = (inner_row - np.mean(inner_row)) / (np.std(inner_row) * len(inner_row))</span>
                <span class="c1"># b = (outer_row - np.mean(outer_row)) / (np.std(outer_row) )</span>
                <span class="c1"># x = np.correlate(a, b)</span>
            <span class="n">ccm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">ccm</span></div>


<div class="viewcode-block" id="linear">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.linear">[docs]</a>
<span class="k">def</span> <span class="nf">linear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generic linear function for fitting lines with.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : int, float, or arraylike</span>
<span class="sd">        An independent variable.</span>
<span class="sd">    a : int or float</span>
<span class="sd">        The first model parameter - the coefficient.</span>
<span class="sd">    b : int or float</span>
<span class="sd">        The second model parameter - the intercept term.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : int, float, or arraylike</span>
<span class="sd">        The dependent variable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span></div>


<div class="viewcode-block" id="squareDiff">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.squareDiff">[docs]</a>
<span class="k">def</span> <span class="nf">squareDiff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the difference squared between two arrays or lists (of the same length).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : arraylike</span>
<span class="sd">        A sequence for which to compute the difference with another.</span>
<span class="sd">    y : arraylike</span>
<span class="sd">        The second sequence, which will be compared with the first.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sqdf : arraylike</span>
<span class="sd">        The squared difference between the two arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>


<div class="viewcode-block" id="mape">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.mape">[docs]</a>
<span class="k">def</span> <span class="nf">mape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the mean absolute percentage error between two sequences.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: arraylike</span>
<span class="sd">        The modeled values.</span>
<span class="sd">    y: arraylike</span>
<span class="sd">        The actual (true) values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mape : float</span>
<span class="sd">        The mean absolute percentage error.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">quantity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
    <span class="n">mape</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mape</span></div>


<div class="viewcode-block" id="plotHist">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.plotHist">[docs]</a>
<span class="k">def</span> <span class="nf">plotHist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">saveLoc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logScale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given data and bins, plot a histogram and fit a distribution to it.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : arraylike</span>
<span class="sd">        1D data to make a histogram with.</span>
<span class="sd">    bins : arraylike</span>
<span class="sd">        The bins with which to bin the data.</span>
<span class="sd">    color : str</span>
<span class="sd">        The color of the histogram data that will be in the plot.</span>
<span class="sd">    saveLoc : str</span>
<span class="sd">        A string containing the location with which to save the file.</span>
<span class="sd">    labels: list</span>
<span class="sd">        A 3-element list containing string for the xlabel, ylabel, and the title.</span>
<span class="sd">    logScale : bool</span>
<span class="sd">        If &#39;x&#39;, scales the x-axis on a log scale. If &#39;y&#39;, scales the y-axis on a log scale. If &#39;both&#39;, scales both.</span>
<span class="sd">    density : bool</span>
<span class="sd">        If True, computes the density curve of the histogram. If False, simply fits a skew normal distribution to the</span>
<span class="sd">        data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fig : matplotlib.figure</span>
<span class="sd">        A figure object containing the histogram.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">validLocs</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">xVals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">cleanData</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">validLocs</span><span class="p">]</span>
    <span class="n">prunedData</span> <span class="o">=</span> <span class="n">cleanData</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">cleanData</span> <span class="o">&gt;=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cleanData</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">density</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Data&#39;</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">skewnorm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">prunedData</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">skewnorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">xVals</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xVals</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;Fit: $\alpha$=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;, $\xi$=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;, $\omega$=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">prunedData</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">line_kws</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;lw&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
    <span class="c1"># Text and labeling:</span>
    <span class="n">wavelength_str</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="o">-</span><span class="mi">18</span><span class="p">:]</span> <span class="c1"># Valid only for wavelengths under 1000 Angstroms</span>
    <span class="n">textstr</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&#39;</span><span class="o">+</span><span class="n">wavelength_str</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;$\mu$: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">prunedData</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> $\sigma$: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">prunedData</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">textstr</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">37</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">37</span><span class="p">)</span>
    <span class="c1"># plt.title(labels[2], fontsize=35)</span>
    <span class="c1"># plt.legend(loc=&#39;best&#39;)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="o">-</span><span class="mf">25.</span><span class="p">,</span> <span class="mf">25.</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">logScale</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">logScale</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">logScale</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">density</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Skewnormal Parameters: Alpha=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, Loc=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, Scale=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, Kurtosis=&#39;</span><span class="o">+</span>
              <span class="nb">str</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">kurtosis</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">validLocs</span><span class="p">]))</span><span class="o">+</span><span class="s1">&#39;, Skew=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">validLocs</span><span class="p">])))</span>
    <span class="k">if</span> <span class="n">saveLoc</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">saveLoc</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saved figure to &#39;</span><span class="o">+</span><span class="n">saveLoc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="percDev">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.percDev">[docs]</a>
<span class="k">def</span> <span class="nf">percDev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the percentage deviation (a.k.a. percentage error).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param x: float or arraylike</span>
<span class="sd">        The observed value(s).</span>
<span class="sd">    :param y: float or arraylike</span>
<span class="sd">        The true value(s).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    percentDev : float or arraylike</span>
<span class="sd">        The percent deviation between the two arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span></div>


<div class="viewcode-block" id="readFISM2">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.readFISM2">[docs]</a>
<span class="k">def</span> <span class="nf">readFISM2</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a FISM2 netcdf file, read it in and output a .dat file with the same format as the .dat files here:</span>
<span class="sd">    https://github.com/aaronjridley/GITM/tree/master/srcData/FISM</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        The location of the FISM2 file to read in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">netCDF4</span> <span class="kn">import</span> <span class="n">Dataset</span>
    <span class="n">fism2Data</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

    <span class="n">irradiance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fism2Data</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;irradiance&#39;</span><span class="p">])</span>  <span class="c1"># W/m^2/nm</span>
    <span class="n">dates</span> <span class="o">=</span> <span class="n">fism2Data</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span>
    <span class="n">datetimes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">)):</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">day</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">:]</span>
        <span class="n">currentDatetime</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">year</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">day</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">datetimes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentDatetime</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">numStr</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;fism2irr_daily.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fism2File</span><span class="p">:</span>
        <span class="n">fism2File</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;#START</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">dateStr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">datetimes</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">numStr</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">datetimes</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">5</span><span class="p">:</span><span class="mi">7</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">numStr</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">datetimes</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">8</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">timeStr</span> <span class="o">=</span> <span class="s1">&#39;  0  0  0 &#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">timeStr</span> <span class="o">=</span> <span class="s1">&#39; 12  0  0 &#39;</span>
        <span class="n">dateTimeStr</span> <span class="o">=</span> <span class="n">dateStr</span> <span class="o">+</span> <span class="n">timeStr</span>
        <span class="n">strList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">irradiance</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]]</span>
        <span class="n">irrStr</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strList</span><span class="p">)</span>
        <span class="n">fileStr</span> <span class="o">=</span> <span class="n">dateTimeStr</span> <span class="o">+</span> <span class="n">irrStr</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">fism2File</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fileStr</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Wrote file to: &#39;</span><span class="o">+</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s1">&#39;/fism2irr_daily.dat&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="readCLS">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.readCLS">[docs]</a>
<span class="k">def</span> <span class="nf">readCLS</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load in flare-corrected, Sun-Earth distance adjusted flux values recorded by the Collecte Localisation Satellites</span>
<span class="sd">    (CLS).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        The location of the data file.</span>
<span class="sd">    times : list</span>
<span class="sd">        The datetimes for each data value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        The solar flux data for F30, F15, F10.7, F8, and F3.2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">precisionVals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">myFile</span><span class="p">:</span>
        <span class="n">allLines</span> <span class="o">=</span> <span class="n">myFile</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">allLines</span><span class="p">)</span><span class="o">-</span><span class="mi">25</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">allLines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">25</span><span class="p">:</span>
                <span class="n">elements</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">9</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">13</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">17</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">21</span><span class="p">])])</span>
                <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">datetime</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="mi">12</span><span class="p">)</span> <span class="p">)</span>
                <span class="n">precisionVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">6</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">10</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">14</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">18</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">22</span><span class="p">])]</span> <span class="p">)</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Print the precision:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean precision values...&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F30: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">([</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">precisionVals</span><span class="p">]))</span><span class="o">+</span><span class="s1">&#39; sfu&#39;</span><span class="p">)</span> <span class="c1"># 6</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F15: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">([</span><span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">precisionVals</span><span class="p">]))</span> <span class="o">+</span> <span class="s1">&#39; sfu&#39;</span><span class="p">)</span> <span class="c1"># 8</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F10.7: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">([</span><span class="n">element</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">precisionVals</span><span class="p">]))</span> <span class="o">+</span> <span class="s1">&#39; sfu&#39;</span><span class="p">)</span> <span class="c1"># 13</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F8: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">([</span><span class="n">element</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">precisionVals</span><span class="p">]))</span> <span class="o">+</span> <span class="s1">&#39; sfu&#39;</span><span class="p">)</span> <span class="c1"># 12</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F3.2: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">([</span><span class="n">element</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">precisionVals</span><span class="p">]))</span> <span class="o">+</span> <span class="s1">&#39; sfu&#39;</span><span class="p">)</span> <span class="c1"># 11</span>
    <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">data</span></div>


<div class="viewcode-block" id="band_info">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.band_info">[docs]</a>
<span class="k">def</span> <span class="nf">band_info</span><span class="p">(</span><span class="n">bin_boundaries_left</span><span class="p">,</span> <span class="n">bin_boundaries_right</span><span class="p">,</span> <span class="n">solomon</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a two array-likes of wavelength bin boundaries, return the indices of those corresponding only to wavelength</span>
<span class="sd">    ranges, rather than individual lines, and also return the wavelength boundaries themselves.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bin_boundaries_left : arraylike</span>
<span class="sd">        The left-sided wavelength band boundaries. May either be in nm or Angstroms.</span>
<span class="sd">    bin_boundaries_right : arraylike</span>
<span class="sd">        The right-sided wavelength band boundaries. May either be in nm or Angstroms. Units should match those of</span>
<span class="sd">        bin_boundaries_left.</span>
<span class="sd">    solomon : boolean</span>
<span class="sd">        If True, does the same thing, but accounts for overlapping bands in the solomon bins. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sortInds : arraylike</span>
<span class="sd">        The indices of the wavelength ranges only.</span>
<span class="sd">    xPosSorted : arraylike</span>
<span class="sd">        The values of the wavelength ranges themselves, for the purposes of making spectral stair plots.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">solomon</span><span class="p">:</span>
        <span class="c1"># Individual wavelength lines should have the same value for the left and right boundaries, so find the indices where</span>
        <span class="c1"># that is NOT true:</span>
        <span class="n">bandInds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_boundaries_left</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_boundaries_right</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Append the right-most boundary to ensure that the resulting boundary values are &#39;closed&#39; on both sides.</span>
        <span class="n">xPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_boundaries_left</span><span class="p">)[</span><span class="n">bandInds</span><span class="p">],</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_boundaries_right</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Sort the indices:</span>
        <span class="n">sortInds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xPos</span><span class="p">)</span>
        <span class="c1"># Return the sorted boundary values for ease of plotting:</span>
        <span class="n">xPosSorted</span> <span class="o">=</span> <span class="n">xPos</span><span class="p">[</span><span class="n">sortInds</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sortInds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xPosSorted</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xPosSolomonInitial</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bin_boundaries_left</span> <span class="o">+</span> <span class="n">bin_boundaries_right</span><span class="p">)</span>
        <span class="n">xPosSolomon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xPosSolomonInitial</span><span class="p">,</span> <span class="mf">1130.</span><span class="p">)</span>
        <span class="n">bandWidths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_boundaries_right</span><span class="p">,</span> <span class="mf">1130.</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_boundaries_left</span><span class="p">,</span> <span class="n">bin_boundaries_right</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Constrain the bins; i.e. for the overlapping bins, we will want to sum everything in there together:</span>
        <span class="n">xPosSolomonNew</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xPosSolomon</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xPosSolomon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">xPosSolomon</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">xPosSolomonNew</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xPosSolomon</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">xPosSolomon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xPosSolomonNew</span><span class="p">)</span>
        <span class="n">sortIndsSolomon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xPosSolomon</span><span class="p">)</span>
        <span class="c1"># The edges of the bins are what we want:</span>
        <span class="n">xPosSortedSolomon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">155</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">290</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">650</span><span class="p">,</span> <span class="mi">798</span><span class="p">,</span> <span class="mi">913</span><span class="p">,</span> <span class="mi">975</span><span class="p">,</span> <span class="mi">987</span><span class="p">,</span>
                                      <span class="mi">1027</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">sortIndsSolomon</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xPosSortedSolomon</span></div>


<div class="viewcode-block" id="solomonRebin">
<a class="viewcode-back" href="../../../EUVpy.tools.toolbox.html#EUVpy.tools.toolbox.solomonRebin">[docs]</a>
<span class="k">def</span> <span class="nf">solomonRebin</span><span class="p">(</span><span class="n">solomonIrr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some irradiance in the Solomon Bins, do a simple rebinning procedure to simply sum the irradiance in the</span>
<span class="sd">    overlapping bins, so that the resulting spectra can be plotted rather easily.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    solomonIrr : numpyn.ndarray</span>
<span class="sd">        An array of irradiance in the Solomon Bins. Rows are observations and columns are wavelength bins.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    solomonIrr_for_plotting: numpy.ndarray</span>
<span class="sd">        The rebinned irradiance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">solomonTable</span> <span class="o">=</span> <span class="n">solomon</span><span class="o">.</span><span class="n">solomonBands</span>
    <span class="c1"># sortIndsSolomon, xPosSortedSolomon = band_info(solomonTable[&#39;short&#39;], solomonTable[&#39;long&#39;], solomon=True)</span>
    <span class="n">xPosSolomonInitial</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">solomonTable</span><span class="p">[</span><span class="s1">&#39;short&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">solomonTable</span><span class="p">[</span><span class="s1">&#39;long&#39;</span><span class="p">])</span>
    <span class="n">xPosSolomon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xPosSolomonInitial</span><span class="p">,</span> <span class="mf">1130.</span><span class="p">)</span>
    <span class="n">goodInds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">])</span>  <span class="c1"># badInds: 12, 14, 15, 17, 18</span>
    <span class="n">solomonIrr_for_plotting</span> <span class="o">=</span> <span class="n">solomonIrr</span><span class="p">[:,</span> <span class="n">goodInds</span><span class="p">]</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xPosSolomon</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">xPosSolomon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">xPosSolomon</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># Do nothing</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">solomonIrr_for_plotting</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">solomonIrr</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">solomonIrr_for_plotting</span></div>

<span class="c1">########################################################################################################################</span>
<span class="c1"># TODO: Python versions of Liying Qian&#39;s Wavelength Rebinning Code from here: https://download.hao.ucar.edu/pub/lqian/tlsm/idl/</span>



<span class="c1">#-----------------------------------------------------------------------------------------------------------------------</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Michigan Tech Research Institute.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>